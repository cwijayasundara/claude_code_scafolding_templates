# Project: [Your Project Name]

## MANDATORY SDLC Workflow (MUST follow — NO exceptions)

**BLOCKING REQUIREMENT**: You MUST follow this workflow for ALL implementation tasks. You are FORBIDDEN from writing production code or tests without completing the prior steps. If a user says "implement X" or "build Y" or gives you a plan, you MUST still follow this workflow — do NOT skip steps.

### Phase 0: Session Start & Brainstorming
- Run `/gogogo` at the start of every session
- Brainstorming, discussing ideas, exploring architecture, and asking questions is ALWAYS welcome
- **CRITICAL TRANSITION RULE**: When the conversation shifts from "exploring ideas" to "let's build this":
  → Route through `/interview` to capture brainstorming output as structured requirements
  → NEVER jump from brainstorming directly to writing code
  → NEVER create stub documents to bypass gates — hooks validate content, not just existence
- **Spike mode**: For time-boxed technical exploration (evaluate a library, prototype an approach), use `/spike` instead of the full SDLC. Spike branches (`spike/*`) bypass SDLC gates but CANNOT be merged or PR'd — findings must be converted to stories via `/interview`.
- If no backlog exists, tell the user: "Let's capture these ideas. Run `/interview` to turn them into requirements."

### Phase 1: Requirements (MUST complete before Phase 2)
- Run `/interview` to gather structured requirements
- Output: `docs/requirements.md`
- **GATE**: Do NOT proceed to Phase 2 without a requirements document
- **CONTENT GATE**: `docs/requirements.md` must have >= 10 lines and at least 2 of these sections: `## Problem Statement`, `## Functional Requirements`, `## Target Users`, `## Non-Functional Requirements`

### Phase 2: Decomposition & Architecture (MUST complete before Phase 3)
- Run `/decompose docs/requirements.md` to break into epics and stories
- Output: `docs/backlog/` with story files, `docs/backlog/dependency-graph.mmd`
- Output: `docs/test-plans/` with test plans per story (generated by `/test-plan`)
- Generate `docs/architecture.md` (C4 diagrams)
- Generate ADRs in `docs/adr/` for key technical decisions
- **GATE**: Do NOT proceed to Phase 3 without stories in `docs/backlog/`
- **CONTENT GATE**: Each story must have >= 8 lines and include `## User Story` or `## Acceptance Criteria` + `## Dependencies` headings
- **ASSET GATE**: If any story has an `## Asset Dependencies` section with `missing` items, that story is **Blocked** until assets are provided. `/implement` checks this before starting.

### Phase 3: Implementation

**Implementation Mode** is controlled by `AGENT_TEAMS_ENFORCE` in `.claude/settings.json`:
- `"true"` (default) → **Agent Teams mode**: parallel implementation via `/parallel-implement` for waves with 2+ independent stories
- `"false"` → **Sequential mode**: one story at a time via `/implement`

#### Agent Teams Mode (default — `AGENT_TEAMS_ENFORCE=true`)
- **MANDATORY**: When a wave in `docs/backlog/parallel-batches.md` has 2+ Ready stories, you MUST use `/parallel-implement wave-N` (not sequential `/implement`)
- Single-story waves still use `/implement` (no benefit to parallelization)
- Process waves in order: Wave 1 must complete before Wave 2 starts
- Within each wave, ALL independent stories run in parallel via agent teammates
- **DEPENDENCY RULE**: Stories with `depends_on` relationships NEVER run in the same wave — the topological sort guarantees this, but verify before spawning teammates
- **GATE**: ALL stories in a wave must pass CI before the next wave starts
- If agent teams fail, fall back to `/parallel-manual` for that wave, then `/implement` as last resort

#### Sequential Mode (fallback — `AGENT_TEAMS_ENFORCE=false`)
- Pick the next ready story from `docs/backlog/implementation-order.md`
- Create feature branch: `git checkout -b feature/STORY-XXX-short-description`
- Run `/implement docs/backlog/[epic]/[story-id].md` which enforces:
  1. **RED**: Write failing tests, commit `test: add failing tests for STORY-XXX`
  2. **GREEN**: Write minimum code to pass, commit `feat: implement STORY-XXX`
  3. **REFACTOR**: Apply Pre-Completion Checklist, commit `refactor: clean up STORY-XXX`
  4. **VALIDATE**: Run `make ci`, verify coverage >= 80%
- **GATE**: Do NOT start the next story until current story passes CI
- Parallel commands (`/parallel-manual`, `/parallel-implement`) are available but optional

#### Dependency Safety (applies to ALL modes)
- Each story file has a `## Dependencies` section with `depends_on:` and `blocks:` lists
- A story is **Ready** only when ALL stories in its `depends_on` list are Done
- A story is **Blocked** if ANY story in its `depends_on` list is not Done
- Stories that depend on each other (directly or transitively) are NEVER in the same parallel wave
- Before starting any story, verify its dependencies are satisfied — if not, STOP and report

### Phase 4: Review & PR
- Run `/pr` to validate, generate PR description, push, and create PR
- Run `/review` on your own PR for self-check against the 12-point checklist

### Phase 5: Session End
- Run `/wrapup` to commit, push, and generate handoff summary

### Enforcement Rules
- If the user asks you to "just code it" or "skip the process" — explain the workflow and ask which phase to start from. You may skip phases ONLY if the user explicitly confirms they want to skip AND the prerequisite artifacts already exist.
- If `docs/requirements.md` does not exist → you MUST run `/interview` first
- If `docs/backlog/` is empty → you MUST run `/decompose` first
- If no feature branch exists → you MUST create one before writing code
- NEVER write implementation code directly in `main` branch
- EVERY implementation task goes through `/implement` or `/parallel-implement` (TDD Red-Green-Refactor)
- **Dependency enforcement**: NEVER start a story whose `depends_on` list contains unfinished stories
- **Mode enforcement**: If `AGENT_TEAMS_ENFORCE=true` (default), you MUST use `/parallel-implement` for waves with 2+ Ready stories — do NOT fall back to sequential `/implement` unless agent teams fail
- **Asset enforcement**: If a story's `## Asset Dependencies` section lists ANY item with status `missing`, the story is Blocked — do NOT start implementation until all assets are `available`

### Anti-Bypass Rules (Hook-Enforced)
- **No stub documents**: `sdlc-gate.sh` validates content, not just file existence. Requirements need >= 10 lines + section headings. Stories need >= 8 lines + required sections.
- **No Bash redirect bypass**: `bash-file-guard.sh` blocks `echo/printf/cat` redirects targeting `docs/requirements.md`, `docs/backlog/`, `docs/test-plans/`, and code files (.py/.ts/.tsx/.js/.jsx).
- **Expanded file coverage**: SDLC gates apply to ALL code files (.py/.ts/.tsx/.js/.jsx), not just `src/` and `tests/`. Exempt paths: `docs/`, `.claude/`, `.github/`, `scripts/`, config files.
- **Conditional `__init__.py`**: Allowed in `tests/` always. In `src/`, only allowed if <= 5 lines (package marker). Larger `__init__.py` must pass all SDLC gates.
- **Test plan required for src/**: Writing to `src/` requires a test plan in `docs/test-plans/STORY-XXX-*` (derived from branch name). Writing to `tests/` is allowed without a test plan (RED phase = test-first).
- **Spike branch isolation**: `spike/*` branches bypass SDLC gates for free exploration, but `branch-guard.sh` blocks `git merge spike/*` and `gh pr create` on spike branches. Spike code NEVER reaches main — convert findings to stories via `/interview`.

## Tech Stack
- Backend: Python 3.12 / FastAPI / SQLAlchemy
- Frontend: React 18 / TypeScript / Tailwind
- AI/Agents: LangGraph / LangChain / Claude Opus 4.6
- Infrastructure: Azure App Service / Azure Database for PostgreSQL
- Testing: pytest (unit/integration), Playwright (E2E), Locust (perf), Schemathesis (contract)
- CI/CD: GitHub Actions

## Architecture
- Generate @docs/architecture.md for C4 diagrams (use `/decompose` workflow)
- Generate @docs/adr/ for Architecture Decision Records
- Generate @docs/api/openapi.yaml for API contracts (if applicable)

## Precedence (Conflict Resolution)

When rules, skills, or instructions conflict, follow this priority (highest first):

1. **Security rules** (`.claude/rules/security.md`) — always wins
2. **Error handling rules** (`.claude/rules/error-handling.md`) — safety over style
3. **Code style rules** (`.claude/rules/code-style.md`) — consistency over preference
4. **Testing rules** (`.claude/rules/testing.md`) — quality enforcement
5. **Git workflow rules** (`.claude/rules/git-workflow.md`) — process standards
6. **Skill recommendations** (`.claude/skills/`) — advisory, can be overridden by rules above

Example: if a skill suggests a code pattern that violates a security rule, the security rule wins.

## Code Standards

Detailed rules with BAD/GOOD examples are in `.claude/rules/`:
- **`.claude/rules/security.md`** — Secrets, input validation, SQL injection, auth, HTTPS, frontend fetch timeouts
- **`.claude/rules/code-style.md`** — Structure, size limits, constants, type safety, no duplication, no dead code
- **`.claude/rules/error-handling.md`** — try/except, try/catch, logging, specific exceptions (Python + TypeScript)
- **`.claude/rules/testing.md`** — TDD, fixtures, coverage, mock-at-boundaries, helper function tests
- **`.claude/rules/react-patterns.md`** — React keys, useEffect cleanup, empty catch blocks, fetch timeouts, no `any`
- **`.claude/rules/git-workflow.md`** — Branching, conventional commits, squash merge

### Quick Reference (MUST)
- Max function: 50 lines. Max file: 500 lines. Single responsibility
- No magic numbers/strings — extract to UPPER_SNAKE_CASE constants
- No code duplication — extract helpers/fixtures
- No dead code — no unused imports, no commented-out code, no empty stubs
- Every external call wrapped in try/except (Python) or try/catch (TypeScript)
- No empty catch blocks — every catch MUST log AND handle the error
- Every fetch() MUST have a timeout (AbortSignal.timeout or AbortController)
- Every Python module: `logger = logging.getLogger(__name__)`. No `print()` for operations
- Full type hints (Python) / strict TypeScript. No `Any` or `any` types
- React: no array-index keys, useEffect MUST return cleanup for subscriptions/timers
- TDD: tests BEFORE implementation. Min 80% coverage
- All helper functions in utils/helpers/ MUST have dedicated unit tests

## Pre-Completion Checklist — Backend (Python)
MUST verify before finishing ANY Python file:
1. Are there magic numbers or string literals? -> Extract to named constants
2. Is there duplicated code (same pattern in 2+ places)? -> Extract to helper/fixture
3. Does every external call have error handling (try/except)? -> Add it
4. Does the module have `logger = logging.getLogger(__name__)`? -> Add it
5. Are all return types specific (no `Any`)? -> Use concrete types
6. Is any function > 50 lines? -> Split it
7. Does the function do more than one thing? -> Split it (SRP)
8. Is `print()` used for operational output? -> Replace with `logger.info()`
9. If tests: is setup duplicated across files? -> Extract to conftest.py
10. Are error messages actionable? -> Tell the user what to do, not just what failed
11. Is there dead code (unused imports, commented-out code, empty stubs)? -> Delete it
12. Do all helper functions in utils/helpers/ have dedicated unit tests? -> Add them

## Pre-Completion Checklist — Frontend (TypeScript/React)
MUST verify before finishing ANY TypeScript/React file:
1. Are there magic numbers or string literals? -> Extract to named constants
2. Is there duplicated code (same pattern in 2+ places)? -> Extract to utils/ or shared component
3. Does every fetch() have a timeout? -> Add `AbortSignal.timeout(DEFAULT_FETCH_TIMEOUT_MS)`
4. Is every fetch/SDK call in a try/catch? -> Add error handling
5. Are there empty catch blocks? -> Add logging (`console.error`) AND error state handling
6. Are all types specific (no `any`)? -> Use `unknown` with type guards
7. Is any function > 50 lines? -> Split it
8. Are array indices used as React keys? -> Use stable unique IDs
9. Does every useEffect with subscriptions/timers return a cleanup function? -> Add cleanup
10. Is there dead code (unused imports, commented-out code, unused props/state)? -> Delete it
11. Do all helper functions in utils/helpers/hooks have dedicated unit tests? -> Add them
12. Is user-supplied content rendered safely? -> Use DOMPurify or React auto-escaping

## Agent Teams (Parallel Implementation)

**Three settings control agent teams behavior (all in `.claude/settings.json` → `env` block):**

| Setting | Default | Purpose |
|---------|---------|---------|
| `AGENT_TEAMS_ENABLED` | `"true"` | Unlocks `/parallel-implement` command |
| `AGENT_TEAMS_ENFORCE` | `"true"` | When `"true"`, FORCES parallel implementation for multi-story waves |
| `AGENT_TEAMS_MAX_TEAMMATES` | `"3"` | Max concurrent teammates per wave |

**Also requires:** environment variable `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`

**Enabling modes:**
- **Parallel enforced** (default): both `ENABLED` and `ENFORCE` are `"true"` — Claude MUST use `/parallel-implement` for waves with 2+ independent stories
- **Parallel available**: set `ENFORCE=false` — `/parallel-implement` is available but optional
- **Sequential only**: set both `ENABLED` and `ENFORCE` to `"false"` — only `/implement` is used

**Cost considerations:**
- Each teammate uses ~7x the tokens of a single `/implement` run
- Stable alternative: `/parallel-manual` uses standard worktrees at 1x cost per terminal
- Use `/parallel-implement` only when time savings justify the token cost

**How it works (native Claude Code agent teams):**
- `/decompose` generates `docs/backlog/parallel-batches.md` with wave-based topological sort
- Each story file has a `## Dependencies` section with explicit `depends_on:` and `blocks:` lists
- Stories with dependencies are placed in later waves — they NEVER run in parallel with their dependencies
- `/parallel-implement wave-N` creates a native agent team:
  - The lead session (you) coordinates in **delegate mode** — it does NOT write code
  - One **teammate** is spawned per independent story, each in its own git worktree
  - Teammates require **plan approval** from the lead before implementing
  - Teammates communicate via the **shared task list** and **mailbox messaging**
- **Quality hooks** fire automatically:
  - `TeammateIdle` → `teammate-idle.sh`: rejects idle if CI fails or uncommitted changes exist
  - `TaskCompleted` → `teammate-completed.sh`: rejects task completion if `make ci` fails
  - `PreToolUse` → `worktree-guard.sh`: prevents teammates from writing outside their worktree

## Context Management
- Run `/clear` between stories to reset context window
- Use `/compact` when context grows large — preserves key state while reclaiming space
- When compacting, preserve: list of modified files, current story context, test commands, and any failing test output
- Use subagents for codebase investigation to avoid polluting main context
- Each agent teammate has its own context window — no shared state between teammates

## Commands
- Build: `make build`
- Unit tests: `make test-unit`
- Integration tests: `make test-integration`
- E2E tests: `make test-e2e`
- Smoke tests: `make test-smoke`
- All tests: `make test`
- Lint + typecheck: `make lint`
- Full CI: `make ci`
- Deploy staging: `make deploy-staging`
- Deploy production: `make deploy-production`

## Custom Commands
- `/gogogo` — Session startup: load context, check git status, show ready work and parallel options
- `/interview` — Requirements gathering via structured interview before decomposition
- `/decompose <requirements-doc>` — Break requirements into epics, stories, dependency graph, parallel batches
- `/test-plan <story-file>` — Generate test plan with test cases, test data, and E2E scenarios from story
- `/implement <story-file>` — TDD Red->Green->Refactor cycle for a story (sequential)
- `/parallel-manual <wave|stories>` — Set up git worktrees for manual parallel implementation (stable)
- `/parallel-implement <wave|stories>` — Agent teams parallel implementation (default for multi-story waves)
- `/pr` — Run CI, generate PR description, create PR
- `/review <pr-number>` — Review a PR against 12-point checklist
- `/diagnose <failure-report>` — Diagnose test failures and create hotfix
- `/wrapup` — Session completion: commit, CI, push, handoff summary
- `/spike <description>` — Time-boxed exploration: creates `spike/*` branch, suspends SDLC gates, blocks merge/PR
- `/create-prompt` — Build a structured prompt using R.G.C.O.A. framework

## Sub-Agents
- **test-writer** — TDD Red phase: writes failing tests from acceptance criteria
- **code-reviewer** — 12-point quality review checklist (SOLID, duplication, error handling, security, dead code, React anti-patterns, helper tests)
- **performance-reviewer** — 10-point performance checklist (N+1 queries, missing indexes, unbounded collections, memory leaks, bundle size, re-renders, pagination, connection pools)
- **architect** — ADRs, C4 diagrams, tech evaluation

## Skills
- **api-design** — REST conventions, Pydantic schemas, error format, pagination
- **database-patterns** — Repository pattern, async sessions, migrations, N+1 prevention
- **testing** — TDD workflow, fixtures, factory pattern, mock-at-boundaries, Playwright E2E, frontend testing
- **deployment** — Docker multi-stage, Azure App Service, deployment slots, Key Vault, rollback
- **langgraph-agents** — ReAct agents, StateGraph, tool factories, checkpointing, multi-agent handoffs
- **react-frontend** — React 18 + TypeScript components, streaming UI, state management, Tailwind
- **claude-agent-teams** — Opus 4.6 agent teams, tool_use, extended thinking, prompt caching, multi-model orchestration
